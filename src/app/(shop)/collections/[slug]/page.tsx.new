import { Metadata } from "next";
import { notFound } from "next/navigation";
import { prisma } from "@/lib/prisma";
import { ProductGrid } from "@/components/shop/product-grid";
import { Breadcrumb } from "@/components/shop/breadcrumb";
import type { Product } from "@/types/product";

interface Collection {
  id: string;
  name: string;
  slug: string;
  description: string | null;
  image: string | null;
  seoTitle: string | null;
  seoDescription: string | null;
  seoKeywords: string | null;
}

interface CollectionWithProducts extends Collection {
  products: Product[];
}

interface CollectionPageProps {
  params: {
    slug: string;
  };
}

async function getCollection(slug: string): Promise<CollectionWithProducts | null> {
  // First, get the collection
  const collection = await prisma.collection.findUnique({
    where: {
      slug: slug,
    },
    select: {
      id: true,
      name: true,
      slug: true,
      description: true,
      image: true,
      seoTitle: true,
      seoDescription: true,
      seoKeywords: true,
    },
  });

  if (!collection) {
    return null;
  }

  // Then, get the products for this collection
  const productCollections = await prisma.productCollection.findMany({
    where: {
      collectionId: collection.id,
    },
    include: {
      product: {
        include: {
          category: {
            select: {
              id: true,
              name: true,
              slug: true,
            },
          },
          images: {
            select: {
              id: true,
              url: true,
              order: true,
            },
            orderBy: {
              order: 'asc',
            },
          },
        },
      },
    },
  });

  // Transform the products to match our expected type
  const products = productCollections.map(pc => {
    const product = pc.product;
    return {
      id: product.id,
      name: product.name,
      description: product.description,
      descriptionHtml: product.descriptionHtml,
      handle: product.handle,
      price: product.price,
      compareAtPrice: product.compareAtPrice,
      costPerItem: product.costPerItem,
      stock: product.stock,
      reservedStock: product.reservedStock,
      slug: product.slug,
      isActive: product.isActive,
      status: product.status,
      image: product.image,
      sku: product.sku,
      barcode: product.barcode,
      inventoryTracking: product.inventoryTracking,
      inventoryPolicy: product.inventoryPolicy,
      allowBackorder: product.allowBackorder,
      lowStockThreshold: product.lowStockThreshold,
      taxable: product.taxable,
      taxCode: product.taxCode,
      weight: product.weight,
      weightUnit: product.weightUnit,
      requiresShipping: product.requiresShipping,
      shippingProfile: product.shippingProfile,
      fulfillmentService: product.fulfillmentService,
      metaTitle: product.metaTitle,
      metaDescription: product.metaDescription,
      metaKeywords: product.metaKeywords,
      ogImage: product.ogImage,
      twitterImage: product.twitterImage,
      seoTitle: product.seoTitle,
      seoDescription: product.seoDescription,
      seoKeywords: product.seoKeywords,
      vendor: product.vendor,
      type: product.type,
      tags: product.tags,
      images: product.images.map(img => ({
        id: img.id,
        url: img.url,
        order: img.order,
        productId: product.id,
        createdAt: new Date(),
        updatedAt: new Date(),
      })),
      variants: [],
      metafields: [],
      category: product.category ? {
        id: product.category.id,
        name: product.category.name,
        slug: product.category.slug,
        description: null,
        image: null,
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date(),
        order: 0,
      } : undefined,
    } as Product;
  });

  return {
    ...collection,
    products,
  };
}

export async function generateMetadata({ params }: CollectionPageProps): Promise<Metadata> {
  const collection = await getCollection(params.slug);
  
  if (!collection) {
    return {
      title: "Collection Not Found | BinWahab",
      description: "The requested collection could not be found",
    };
  }
  
  return {
    title: collection.seoTitle || `${collection.name} | BinWahab`,
    description: collection.seoDescription || collection.description || `Browse our ${collection.name} collection`,
    keywords: collection.seoKeywords || undefined,
    openGraph: {
      title: collection.seoTitle || `${collection.name} | BinWahab`,
      description: collection.seoDescription || collection.description || undefined,
      images: collection.image ? [{ url: collection.image }] : undefined,
    },
    twitter: {
      card: 'summary_large_image',
      title: collection.seoTitle || `${collection.name} | BinWahab`,
      description: collection.seoDescription || collection.description || undefined,
      images: collection.image ? [collection.image] : undefined,
    },
  };
}

export default async function CollectionPage({ params }: CollectionPageProps) {
  const collection = await getCollection(params.slug);

  if (!collection) {
    notFound();
  }

  const breadcrumbItems = [
    {
      label: "Collections",
      href: "/collections",
    },
    {
      label: collection.name,
      href: `/collections/${collection.slug}`,
    },
  ];

  return (
    <div className="container mx-auto px-4 py-8">
      <Breadcrumb items={breadcrumbItems} />
      <h1 className="text-3xl font-bold mb-8">{collection.name}</h1>
      {collection.description && (
        <div className="prose max-w-none mb-8">
          <p>{collection.description}</p>
        </div>
      )}
      <ProductGrid products={collection.products} />
    </div>
  );
} 